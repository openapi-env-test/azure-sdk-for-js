/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { Job } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { SingularityManagementClient } from "../singularityManagementClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  JobResourceDescription,
  JobListByAccountNextOptionalParams,
  JobListByAccountOptionalParams,
  JobCreateOrUpdateOptionalParams,
  JobCreateOrUpdateResponse,
  JobResourcePatchDescription,
  JobUpdateOptionalParams,
  JobUpdateResponse,
  JobGetOptionalParams,
  JobGetResponse,
  JobDeleteOptionalParams,
  JobApproveOptionalParams,
  JobCreateSasTokenOptionalParams,
  JobCreateSasTokenResponse,
  JobRenewKeyOptionalParams,
  JobRenewKeyResponse,
  JobSuspendOptionalParams,
  JobResumeOptionalParams,
  JobCancelOptionalParams,
  JobListByAccountResponse,
  JobRemoveOptionalParams,
  JobListByAccountNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing Job operations. */
export class JobImpl implements Job {
  private readonly client: SingularityManagementClient;

  /**
   * Initialize a new instance of the class Job class.
   * @param client Reference to the service client
   */
  constructor(client: SingularityManagementClient) {
    this.client = client;
  }

  /**
   * Gets the information about all the job resources in a given account. The information include the
   * description and other properties of the job.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param options The options parameters.
   */
  public listByAccount(
    resourceGroupName: string,
    accountName: string,
    options?: JobListByAccountOptionalParams
  ): PagedAsyncIterableIterator<JobResourceDescription> {
    const iter = this.listByAccountPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByAccountPagingPage(
          resourceGroupName,
          accountName,
          options
        );
      }
    };
  }

  private async *listByAccountPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: JobListByAccountOptionalParams
  ): AsyncIterableIterator<JobResourceDescription[]> {
    let result = await this._listByAccount(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByAccountNext(
        resourceGroupName,
        accountName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByAccountPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: JobListByAccountOptionalParams
  ): AsyncIterableIterator<JobResourceDescription> {
    for await (const page of this.listByAccountPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Creates a job resource with the specified name, description and properties. If a job with the same
   * name exists, then it is updated with the specified description and properties.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param body Singularity job information.
   * @param options The options parameters.
   */
  async beginCreateOrUpdate(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    body: JobResourceDescription,
    options?: JobCreateOrUpdateOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<JobCreateOrUpdateResponse>,
      JobCreateOrUpdateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<JobCreateOrUpdateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, body, options },
      createOrUpdateOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates a job resource with the specified name, description and properties. If a job with the same
   * name exists, then it is updated with the specified description and properties.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param body Singularity job information.
   * @param options The options parameters.
   */
  async beginCreateOrUpdateAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    body: JobResourceDescription,
    options?: JobCreateOrUpdateOptionalParams
  ): Promise<JobCreateOrUpdateResponse> {
    const poller = await this.beginCreateOrUpdate(
      resourceGroupName,
      accountName,
      jobName,
      body,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Updates a job resource with the specified properties. If a job with the same name exists, then it is
   * updated with the specified properties. If a job doesn't exist, then a no-content exception will be
   * thrown
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param body Singularity job information.
   * @param options The options parameters.
   */
  async beginUpdate(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    body: JobResourcePatchDescription,
    options?: JobUpdateOptionalParams
  ): Promise<
    PollerLike<PollOperationState<JobUpdateResponse>, JobUpdateResponse>
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<JobUpdateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, body, options },
      updateOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Updates a job resource with the specified properties. If a job with the same name exists, then it is
   * updated with the specified properties. If a job doesn't exist, then a no-content exception will be
   * thrown
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param body Singularity job information.
   * @param options The options parameters.
   */
  async beginUpdateAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    body: JobResourcePatchDescription,
    options?: JobUpdateOptionalParams
  ): Promise<JobUpdateResponse> {
    const poller = await this.beginUpdate(
      resourceGroupName,
      accountName,
      jobName,
      body,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the information about the job resource with the given name. The information include the
   * description and other properties of the job.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  get(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobGetOptionalParams
  ): Promise<JobGetResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, jobName, options },
      getOperationSpec
    );
  }

  /**
   * Deletes the job resource identified by the name.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginDelete(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobDeleteOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      deleteOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes the job resource identified by the name.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginDeleteAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobDeleteOptionalParams
  ): Promise<void> {
    const poller = await this.beginDelete(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * This action can be used by the account admin to approve a job manually, which is otherwise blocked
   * by insufficient user-level quota (represented by Group Policy).
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginApprove(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobApproveOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      approveOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * This action can be used by the account admin to approve a job manually, which is otherwise blocked
   * by insufficient user-level quota (represented by Group Policy).
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginApproveAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobApproveOptionalParams
  ): Promise<void> {
    const poller = await this.beginApprove(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Creates a Shared Access Signature (SAS) token, that can be used for accessing job resource with the
   * protocol specified in the description.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginCreateSasToken(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobCreateSasTokenOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<JobCreateSasTokenResponse>,
      JobCreateSasTokenResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<JobCreateSasTokenResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      createSasTokenOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates a Shared Access Signature (SAS) token, that can be used for accessing job resource with the
   * protocol specified in the description.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginCreateSasTokenAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobCreateSasTokenOptionalParams
  ): Promise<JobCreateSasTokenResponse> {
    const poller = await this.beginCreateSasToken(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Renews to the Shared Access Signature (SAS) token singining key for the job. It invalidates all
   * tokens generated prior to key rotation
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  renewKey(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobRenewKeyOptionalParams
  ): Promise<JobRenewKeyResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, jobName, options },
      renewKeyOperationSpec
    );
  }

  /**
   * Suspending a job will stop the current execution and release any resources and quota reservations.
   * The job will remain in the Suspended state until resumed or deleted.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginSuspend(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobSuspendOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      suspendOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Suspending a job will stop the current execution and release any resources and quota reservations.
   * The job will remain in the Suspended state until resumed or deleted.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginSuspendAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobSuspendOptionalParams
  ): Promise<void> {
    const poller = await this.beginSuspend(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Resuming a paused job will attempt to return the job into the running state by reserving quota and
   * scheduling execution.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginResume(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobResumeOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      resumeOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Resuming a paused job will attempt to return the job into the running state by reserving quota and
   * scheduling execution.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginResumeAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobResumeOptionalParams
  ): Promise<void> {
    const poller = await this.beginResume(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Cancel the job operation without deleting the resource.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginCancel(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobCancelOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      cancelOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Cancel the job operation without deleting the resource.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginCancelAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobCancelOptionalParams
  ): Promise<void> {
    const poller = await this.beginCancel(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the information about all the job resources in a given account. The information include the
   * description and other properties of the job.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param options The options parameters.
   */
  private _listByAccount(
    resourceGroupName: string,
    accountName: string,
    options?: JobListByAccountOptionalParams
  ): Promise<JobListByAccountResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listByAccountOperationSpec
    );
  }

  /**
   * Remove job operation is used to delete a job that is associated with a group policy.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginRemove(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobRemoveOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, jobName, options },
      removeOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Remove job operation is used to delete a job that is associated with a group policy.
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param jobName The name of the Singularity job.
   * @param options The options parameters.
   */
  async beginRemoveAndWait(
    resourceGroupName: string,
    accountName: string,
    jobName: string,
    options?: JobRemoveOptionalParams
  ): Promise<void> {
    const poller = await this.beginRemove(
      resourceGroupName,
      accountName,
      jobName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * ListByAccountNext
   * @param resourceGroupName The name of the resource group within the user's subscription.
   * @param accountName The name of the Singularity account.
   * @param nextLink The nextLink from the previous successful call to the ListByAccount method.
   * @param options The options parameters.
   */
  private _listByAccountNext(
    resourceGroupName: string,
    accountName: string,
    nextLink: string,
    options?: JobListByAccountNextOptionalParams
  ): Promise<JobListByAccountNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, nextLink, options },
      listByAccountNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const createOrUpdateOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.JobResourceDescription
    },
    201: {
      bodyMapper: Mappers.JobResourceDescription
    },
    202: {
      bodyMapper: Mappers.JobResourceDescription
    },
    204: {
      bodyMapper: Mappers.JobResourceDescription
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body6,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const updateOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.JobResourceDescription
    },
    201: {
      bodyMapper: Mappers.JobResourceDescription
    },
    202: {
      bodyMapper: Mappers.JobResourceDescription
    },
    204: {
      bodyMapper: Mappers.JobResourceDescription
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body7,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobResourceDescription
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const approveOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/approve",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body8,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const createSasTokenOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/createsastoken",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    201: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    202: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    204: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body9,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const renewKeyOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/renewkey",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    201: {
      bodyMapper: Mappers.JobSasTokenDescription
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const suspendOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/suspend",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body8,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const resumeOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/resume",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body8,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const cancelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/cancel",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body8,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listByAccountOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobResourceDescriptionList
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.continuationToken],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const removeOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Singularity/accounts/{accountName}/jobs/{jobName}/remove",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  requestBody: Parameters.body8,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.jobName
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listByAccountNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobResourceDescriptionList
    },
    default: {
      bodyMapper: Mappers.ErrorModel
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.continuationToken],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.nextLink
  ],
  headerParameters: [Parameters.accept],
  serializer
};
